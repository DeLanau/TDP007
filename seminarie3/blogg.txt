Seminarium 3: 

Dokumentation av uppgift 1: 

Denna uppgift har två lösningar. Gruppen var kluven på vilken lösning som är “rätt”. Första lösningen har policy filen hash med alla specifikationer. Det är ganska tydligt att se vad de står för men det kanske inte är helt användar vänligt. Användaren kan missa att lägga till citat-tecken till nycklarna i hashen exempelvis. Därför gjordes uppgiften om och method missing användes. Där togs värden rakt av och adderades med points. Specifikationen kring vad som händer med poängen när använderen matar in Volvo, 3 år erfarenhet och man hanteras i funktionen rules. Funktionen calc_range() gör om specifikationen i policy filen till ranges och kollar om inmatningen passar in i aktuell range. Det har implementerats tester för samma fall i de båda lösningarna för att se att de löser problemet trots att de är olika.  

Dokumentation av uppgift 2: 

Det som förvirrade oss i början var att förstå specifikationen, då expression skrevs som ex. or _ _ istället för _ or _ som kändes mest logiskt. Sedan fick vi förklarat att det är skrivet från ett annat programmeringsspråk Lisp där “or” i detta exempel sågs som en funktion, och förstod kopplingen mellan det och vad som ska returneras. Alltså att “or a b” är samma sak som “a or b” 

Vi utgick ifrån specifikationen, vi då satte rules efter det. Till en början testade vi or, and, not med “true” och “false” för att förstå konceptet, för att se resultatet och jämföra med våra använde vi Rubys interpretator (irb). Det gick bra, sedan när vi började på assigment så sparade vi variabeln i en hash-tabell så vi sedan kan nå den. Därför har vi en if-sats när vi matchar variabeln (var) för att se om den har något sparat värde och returnera det, om det inte finns så returnerar vi bara variabeln som vanligt. Problemet vi stötte på där är att vi hade match-raderna i fel ordning som gjorde att “true” och “false” inte matchade som värdet “true” och “false” utan som en string, vilket gjorde att de inte utvärderades som dess värde som i sin tur gav fel svar. Nästa problem vi stötte på var ett fall i assignment. När en sparad variabel tilldelades ett annat värde så funkade sparades inte det nya värdet utan variabeln hade samma värde fortfarande. Lösningen till det var att flytta blocken som ändrade det till det tidigare regeln. Det spårades genom att matchning historik i interpretatorn. Funktionen parse är tillagt för att underlätta testningen. Inmatningen vid testningen är det som skrivs i terminalen och resultat är det terminalen returnerar. Även i testningen användes rubys interpretator för att jämföra resultaten.  